
---
AWSTemplateFormatVersion: '2010-09-09'
Description: 'QS(5042) Kubernetes AWS CloudFormation Template: Create a Kubernetes
  cluster in a new VPC. The master node is an auto-recovering Amazon EC2
  instance. 1-20 additional EC2 instances in an AutoScalingGroup join the
  Kubernetes cluster as nodes. An ELB provides configurable external access
  to the Kubernetes API. The new VPC includes a bastion host to grant
  SSH access to the private subnet for the cluster. This template creates
  two stacks: one for the new VPC and one for the cluster. The stack is
  suitable for development and small single-team clusters. **WARNING** This
  template creates four Amazon EC2 instances with default settings. You will
  be billed for the AWS resources used if you create a stack from this template.'

# The Metadata tells AWS how to display the parameters during stack creation
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
    - Label:
        default: Required
      Parameters:
      - AvailabilityZone
      - AdminIngressLocation
      - KeyName
    - Label:
        default: Advanced
      Parameters:
      - NetworkingProvider
      - K8sNodeCapacity
      - InstanceType
      - DiskSizeGb
      - BastionInstanceType
      - QSS3BucketName
      - QSS3KeyPrefix

    ParameterLabels:
      KeyName:
        default: SSH Key
      AvailabilityZone:
        default: Availability Zone
      AdminIngressLocation:
        default: Admin Ingress Location
      InstanceType:
        default: Instance Type
      DiskSizeGb:
        default: Disk Size (GiB)
      BastionInstanceType:
        default: Instance Type (Bastion Host)
      K8sNodeCapacity:
        default: Node Capacity
      QSS3BucketName:
        default: S3 Bucket
      QSS3KeyPrefix:
        default: S3 Key Prefix
      NetworkingProvider:
        default: Networking Provider

# The Parameters allow the user to pass custom settings to the stack before creation
Parameters:
  KeyName:
    Description: Existing EC2 KeyPair for SSH access.
    Type: AWS::EC2::KeyPair::KeyName
    ConstraintDescription: must be the name of an existing EC2 KeyPair.

  KeyMaterial:
    Description: Existing EC2 KeyPair Material for SSH access.
    Type: String
  
  ApiKey:
    Description: Password for Datacol Controller API 
    Type: String

  DatacolVersion:
    Description: version of Datacol Controller API
    Type: String

  ArtifactBucket:
    Description: Name of google storage bucket to download datacol binary
    Type: String

  SettingBucket:
    Description: bucket for storing code and environment variables
    Type: String

  InstanceType:
    Description: EC2 instance type for the cluster.
    Type: String
    Default: t2.medium
    AllowedValues:
    - t2.nano
    - t2.micro
    - t2.small
    - t2.medium
    - t2.large
    - m3.medium
    - m3.large
    - m3.xlarge
    - m3.2xlarge
    - m4.large
    - m4.xlarge
    - m4.2xlarge
    - m4.4xlarge
    - m4.10xlarge
    - c3.large
    - c3.xlarge
    - c3.2xlarge
    - c3.4xlarge
    - c3.8xlarge
    - c4.large
    - c4.xlarge
    - c4.2xlarge
    - c4.4xlarge
    - c4.8xlarge
    - g2.2xlarge
    - g2.8xlarge
    - r3.large
    - r3.xlarge
    - r3.2xlarge
    - r3.4xlarge
    - r3.8xlarge
    - i2.xlarge
    - i2.2xlarge
    - i2.4xlarge
    - i2.8xlarge
    - d2.xlarge
    - d2.2xlarge
    - d2.4xlarge
    - d2.8xlarge
    ConstraintDescription: must be a valid EC2 instance type.

  # Specifies the size of the root disk for all EC2 instances, including master
  # and nodes.
  DiskSizeGb:
    Description: 'Size of the root disk for the EC2 instances, in GiB.  Default: 40'
    Default: 40
    Type: Number
    MinValue: 8
    MaxValue: 1024

  BastionInstanceType:
    Description: EC2 instance type for the bastion host (used for public SSH access).
    Type: String
    Default: t2.micro
    AllowedValues:
    - t2.nano
    - t2.micro
    - t2.small
    - t2.medium
    - t2.large
    - m3.medium
    - m3.large
    - m3.xlarge
    - m3.2xlarge
    - m4.large
    - m4.xlarge
    - m4.2xlarge
    - m4.4xlarge
    - m4.10xlarge
    - c3.large
    - c3.xlarge
    - c3.2xlarge
    - c3.4xlarge
    - c3.8xlarge
    - c4.large
    - c4.xlarge
    - c4.2xlarge
    - c4.4xlarge
    - c4.8xlarge
    - g2.2xlarge
    - g2.8xlarge
    - r3.large
    - r3.xlarge
    - r3.2xlarge
    - r3.4xlarge
    - r3.8xlarge
    - i2.xlarge
    - i2.2xlarge
    - i2.4xlarge
    - i2.8xlarge
    - d2.xlarge
    - d2.2xlarge
    - d2.4xlarge
    - d2.8xlarge
    ConstraintDescription: must be a valid EC2 instance type.

  AvailabilityZone:
    Description: The Availability Zone for this cluster. Heptio recommends
      that you run one cluster per AZ and use tooling to coordinate across AZs.
    Type: AWS::EC2::AvailabilityZone::Name
    ConstraintDescription: must be the name of an AWS Availability Zone

  AdminIngressLocation:
    Description: CIDR block (IP address range) to allow SSH access to the 
      bastion host and HTTPS access to the Kubernetes API. Use 0.0.0.0/0
      to allow access from all locations.
    Type: String
    MinLength: '9'
    MaxLength: '18'
    AllowedPattern: "(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})/(\\d{1,2})"
    ConstraintDescription: must be a valid IP CIDR range of the form x.x.x.x/x.

  K8sNodeCapacity:
    Default: '2'
    Description: Initial number of Kubernetes nodes (1-20).
    Type: Number
    MinValue: '1'
    MaxValue: '20'
    ConstraintDescription: must be between 1 and 20 EC2 instances.

  # S3 Bucket configuration: allows users to use their own downstream snapshots
  # of the quickstart-aws-vpc and quickstart-linux-bastion templates
  QSS3BucketName:
    AllowedPattern: "^[0-9a-zA-Z]+([0-9a-zA-Z-]*[0-9a-zA-Z])*$"
    ConstraintDescription: Quick Start bucket name can include numbers, lowercase
      letters, uppercase letters, and hyphens (-). It cannot start or end with a hyphen
      (-).

    Default: quickstart-reference
    Description: Only change this if you have set up assets, like your own networking
      configuration, in an S3 bucket. This and the S3 Key Prefix parameter let you access
      scripts from the scripts/ and templates/ directories of your own fork of the Heptio 
      Quick Start assets, uploaded to S3 and stored at
      ${bucketname}.s3.amazonaws.com/${prefix}/scripts/somefile.txt.S3. The bucket name
      can include numbers, lowercase letters, uppercase letters, and hyphens (-).
      It cannot start or end with a hyphen (-).
    Type: String
  
  QSS3KeyPrefix:
    AllowedPattern: "^[0-9a-zA-Z-]+(/[0-9a-zA-Z-]+)*$"
    ConstraintDescription: Quick Start key prefix can include numbers, lowercase letters,
      uppercase letters, hyphens (-), and forward slash (/). It cannot start or end
      with forward slash (/) because they are automatically appended.
    Default: heptio/latest
    Description: Only change this if you have set up assets in an S3 bucket, as explained
      in the S3 Bucket parameter. The S3 key prefix can include numbers, lowercase letters,
      uppercase letters, hyphens (-), and forward slashes (/). It cannot start or end with
      forward slashes (/) because they are automatically appended.
    Type: String

  NetworkingProvider:
    AllowedValues:
    - calico
    - weave
    ConstraintDescription: 'Currently supported values are "calico" and "weave"'
    Default: calico
    Description: Choose the networking provider to use for communication between
      pods in the Kubernetes cluster. Supported configurations are calico 
      (http://docs.projectcalico.org/v2.0/getting-started/kubernetes/installation/hosted/kubeadm/)
      and weave (https://github.com/weaveworks/weave/blob/master/site/kube-addon.md).
    Type: String

  AWSAccessKey:
    Type: String
  AWSSecretAccessKey:
    Type: String

Mappings:
  RegionMap:
    ap-northeast-1:
      '64': ami-18afc47f
    ap-northeast-2:
      '64': ami-93d600fd
    ap-south-1:
      '64': ami-85ef91ea
    ap-southeast-1:
      '64': ami-d05dd7b3
    ap-southeast-2:
      '64': ami-e6b58e85
    ca-central-1:
      '64': ami-7112a015
    eu-central-1:
      '64': ami-fe408091
    eu-west-1:
      '64': ami-ca80a0b9
    eu-west-2:
      '64': ami-ede2e889
    sa-east-1:
      '64': ami-e075ed8c
    us-east-1:
      '64': ami-9dcfdb8a
    us-east-2:
      '64': ami-fcc19b99
    us-west-1:
      '64': ami-b05203d0
    us-west-2:
      '64': ami-b2d463d2

Conditions:
  UsEast1Condition:
    Fn::Equals:
    - !Ref AWS::Region
    - "us-east-1"

Resources:
  # Resources for new VPC
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: '10.0.0.0/16'
      EnableDnsSupport: 'true'
      EnableDnsHostnames: 'true'
      Tags:
      - Key: Name
        Value: !Ref AWS::StackName

  DHCPOptions:
    Type: AWS::EC2::DHCPOptions
    Properties:
      DomainName:
        # us-east-1 needs .ec2.internal, the rest of the regions get <region>.compute.internal.
        # See http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_DHCP_Options.html
        Fn::If:
        - UsEast1Condition
        - "ec2.internal"
        - !Sub "${AWS::Region}.compute.internal"
      DomainNameServers:
      - AmazonProvidedDNS

  VPCDHCPOptionsAssociation:
    Type: AWS::EC2::VPCDHCPOptionsAssociation
    Properties:
      VpcId: !Ref VPC
      DhcpOptionsId: !Ref DHCPOptions

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
      - Key: Network
        Value: Public

  VPCGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway

  PrivateSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: '10.0.0.0/19'
      AvailabilityZone: !Ref AvailabilityZone
      Tags:
      - Key: Name
        Value: Private subnet
      - Key: Network
        Value: Private

  PublicSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: '10.0.128.0/20'
      AvailabilityZone: !Ref AvailabilityZone
      Tags:
      - Key: Name
        Value: Public subnet
      - Key: Network
        Value: Public
      - Key: KubernetesCluster
        Value: !Ref AWS::StackName
      MapPublicIpOnLaunch: true

  # The NAT IP for the private subnet, as seen from within the public one
  NATEIP:
    DependsOn: VPCGatewayAttachment
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc

  # The NAT gateway for the private subnet
  NATGateway:
    DependsOn: VPCGatewayAttachment
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NATEIP.AllocationId
      SubnetId: !Ref PublicSubnet

  PublicSubnetRoute:
    DependsOn: VPCGatewayAttachment
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PublicSubnetRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PrivateSubnetRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
      - Key: Name
        Value: Private subnets
      - Key: Network
        Value: Private

  PrivateSubnetRoute:
    DependsOn: VPCGatewayAttachment
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateSubnetRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NATGateway

  PrivateSubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PrivateSubnet
      RouteTableId: !Ref PrivateSubnetRouteTable

  PublicSubnetRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
      - Key: Name
        Value: Public Subnets
      - Key: Network
        Value: Public

  PublicSubnetRoute:
    DependsOn: VPCGatewayAttachment
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PublicSubnetRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicSubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet
      RouteTableId: !Ref PublicSubnetRouteTable

  # Taken from github.com/aws-quickstart/quickstart-linux-bastion.  We don't
  # call it directly because that quickstart forces 2 bastion hosts and we only
  # want one
  BastionHost:
    Type: AWS::EC2::Instance
    Properties:
      ImageId:
        Fn::FindInMap:
        - RegionMap
        - Ref: AWS::Region
        - '64'
      InstanceType: !Ref BastionInstanceType
      NetworkInterfaces:
      - AssociatePublicIpAddress: true
        DeleteOnTermination: true
        DeviceIndex: 0
        SubnetId: !Ref PublicSubnet
        # This address is chosen because our public subnet begins at 10.0.128.0/20
        PrivateIpAddress: '10.0.128.5'
        GroupSet:
        - Ref: BastionSecurityGroup
      Tags:
      - Key: Name
        Value: bastion-host
      KeyName: !Ref KeyName
      UserData:
        Fn::Base64:
          Fn::Sub: |
            #!/bin/bash

            mkdir -p /opt/datacol &&
              curl -Ls /tmp https://storage.googleapis.com/${ArtifactBucket}/binaries/${DatacolVersion}/apictl.zip > /tmp/apictl.zip &&
              unzip /tmp/apictl.zip -d /opt/datacol &&
              chmod +x /opt/datacol/apictl
            
            cat <<EOF >> /opt/datacol/${KeyName}.pem
            ${KeyMaterial}
            EOF

            chmod 600 /opt/datacol/${KeyName}.pem
            chown -R ubuntu /opt/datacol
            systemctl daemon-reload && systemctl enable apictl

            cat <<EOF >> /etc/environment
            DATACOL_STACK=${AWS::StackName}
            DATACOL_VERSION=${DatacolVersion}
            DATACOL_BUCKET=${SettingBucket}
            DATACOL_API_KEY=${ApiKey}
            AWS_REGION=${AWS::Region}
            AWS_ACCESS_KEY_ID=${AWSAccessKey}
            AWS_SECRET_ACCESS_KEY=${AWSSecretAccessKey}
            EOF

  # Open up port 22 for SSH for the bastion host
  BastionSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable SSH access via port 22, Api via port 8080 and Grpc via port 10000
      VpcId: !Ref VPC
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: '22'
        ToPort: '22'
        CidrIp: !Ref AdminIngressLocation
      - IpProtocol: tcp
        FromPort: '8080'
        ToPort: '8080'
        CidrIp: !Ref AdminIngressLocation
      - IpProtocol: tcp
        FromPort: '10000'
        ToPort: '10000'
        CidrIp: !Ref AdminIngressLocation

  CodeS3Bucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: "Delete"
    Properties:
      BucketName: !Ref SettingBucket
      AccessControl: "AuthenticatedRead"

  ECRRepository:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: !Sub "${AWS::StackName}-repo"
      RepositoryPolicyText:
        Version: "2008-10-17"
        Statement:
          Sid: "AllowPullPush"
          Effect: "Allow"
          Principal: "*"
          Action:
            - "ecr:*"

  CodeBuildRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          Effect: Allow
          Principal:
              Service: codebuild.amazonaws.com
          Action: sts:AssumeRole

  CloudBuildProject:
    DependsOn: CodeS3Bucket
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Sub "${AWS::StackName}-code-builder"
      TimeoutInMinutes: 15 # 10min
      ServiceRole: !GetAtt CodeBuildRole.Arn
      Environment:
        ComputeType: "BUILD_GENERAL1_SMALL"
        Image: "aws/codebuild/docker:1.12.1"
        Type: "LINUX_CONTAINER"
        EnvironmentVariables:
          - Name: IMAGE_REPO_NAME
            Value: !Ref ECRRepository
          - Name: REGION
            Value: !Ref AWS::Region
          - Name: ACCOUNT_ID
            Value: !Ref AWS::AccountId
          - Name: IMAGE_TAG
            Value: latest
          - Name: APP
            Value: test
      Artifacts:
        Type: "NO_ARTIFACTS"
      Source:
        Type: "S3"
        Location: !Sub "${SettingBucket}/source.zip"
        BuildSpec: !Sub |
          version: 0.2
            phases:
              pre_build:
                commands:
                  - echo Logging into Amazon ECR...
                  - $(aws ecr get-login --region $REGION)
              build:
                commands:
                  - echo Build started on `date`
                  - echo Building the Docker image
                  - docker build -t $IMAGE_REPO_NAME/$APP:$IMAGE_TAG .
              post_build:
                commands:
                  - echo Build started on `date`
                  - echo Pushing the Docker image...
                  - docker tag $IMAGE_REPO_NAME/$APP:$IMAGE_TAG $ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com/$IMAGE_REPO_NAME/$APP:$IMAGE_TAG
                  - docker tag $IMAGE_REPO_NAME/$APP:$IMAGE_TAG $ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com/$IMAGE_REPO_NAME/$APP:latest
                  - echo ***** Build completed *****

  ### Create apps dynamoc table
  DynamoAppTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: 
        Fn::Join:
          - "-" 
          - - !Ref AWS::StackName
            - "apps"
      AttributeDefinitions:
        - AttributeName: name
          AttributeType: "S"
      KeySchema:
        - AttributeName: "name"
          KeyType: "HASH"
      ProvisionedThroughput:
        ReadCapacityUnits: "5"
        WriteCapacityUnits: "5"

  ### Create build dynamodb table
  DynamoBuildTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName:
        Fn::Join:
          - "-" 
          - - !Ref AWS::StackName
            - "builds"
      AttributeDefinitions:
        - AttributeName: "id"
          AttributeType: "S"
      KeySchema:
        - AttributeName: "id"
          KeyType: "HASH"
      ProvisionedThroughput:
        ReadCapacityUnits: "5"
        WriteCapacityUnits: "5"

  ### Create releases dynamodb table
  DynamoBuildTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName:
        Fn::Join:
          - "-" 
          - - !Ref AWS::StackName
            - "releases"
      AttributeDefinitions:
        - AttributeName: "id"
          AttributeType: "S"
      KeySchema:
        - AttributeName: "id"
          KeyType: "HASH"
      ProvisionedThroughput:
        ReadCapacityUnits: "5"
        WriteCapacityUnits: "5"

  # Call the cluster template and supply its parameters
  # This creates a second stack that creates the actual Kubernetes cluster
  # within the new VPC
  K8sStack:
    Type: AWS::CloudFormation::Stack
    Properties:
      TemplateURL: !Sub "https://${QSS3BucketName}.s3.amazonaws.com/${QSS3KeyPrefix}/templates/kubernetes-cluster.template"
      Parameters:
        VPCID: !Ref VPC
        AvailabilityZone: !Ref AvailabilityZone
        InstanceType: !Ref InstanceType
        DiskSizeGb: !Ref DiskSizeGb
        ClusterSubnetId: !Ref PrivateSubnet
        # Direct SSH access only from the bastion host itself
        SSHLocation: !Sub "${BastionHost.PrivateIp}/32"
        ApiLbLocation: !Ref AdminIngressLocation
        KeyName: !Ref KeyName
        K8sNodeCapacity: !Ref K8sNodeCapacity
        QSS3BucketName: !Ref QSS3BucketName
        QSS3KeyPrefix: !Ref QSS3KeyPrefix
        ClusterAssociation: !Ref AWS::StackName
        NetworkingProvider: !Ref NetworkingProvider
        LoadBalancerSubnetId: !Ref PublicSubnet

Outputs:
  # Outputs from VPC creation
  VPCID:
    Description: ID of the newly-created EC2 VPC.
    Value: !Ref VPC

  BastionHostPublicIp:
    Description: IP Address of the bastion host for the newly-created EC2 VPC.
    Value: !GetAtt BastionHost.PublicIp

  BastionHostPublicDNS:
    Description: Public DNS FQDN of the bastion host for the newly-created EC2 VPC.
    Value: !GetAtt BastionHost.PublicDnsName

  SSHProxyCommand:
    Description: Run locally - SSH command to proxy to the master instance
      through the bastion host, to access port 8080 (command to SSH to the master Kubernetes node).
    Value: !Sub >-
      SSH_KEY="path/to/${KeyName}.pem";
      ssh
      -i $SSH_KEY
      -A -L8080:localhost:8080
      -o ProxyCommand="ssh -i \"${!SSH_KEY}\" ubuntu@${BastionHost.PublicIp} nc %h %p"
      ubuntu@${K8sStack.Outputs.MasterPrivateIp}

  GetKubeConfigCommand:
    Description: Run locally - SCP command to download the Kubernetes configuration
      file for accessing the new cluster via kubectl, a Kubernetes command line tool.
      Creates a "kubeconfig" file in the current directory. Then, you can run
      "export KUBECONFIG=$(pwd)/kubeconfig" to ensure kubectl uses this configuration file.
      About kubectl - https://kubernetes.io/docs/user-guide/prereqs/ 
    Value: !Sub >-
      SSH_KEY="path/to/${KeyName}.pem";
      scp
      -i $SSH_KEY
      -o ProxyCommand="ssh -i \"${!SSH_KEY}\" ubuntu@${BastionHost.PublicIp} nc %h %p"
      ubuntu@${K8sStack.Outputs.MasterPrivateIp}:~/kubeconfig ./kubeconfig

  # Outputs forwarded from the k8s template
  MasterInstanceId:
    Description: InstanceId of the master EC2 instance.
    Value: !GetAtt K8sStack.Outputs.MasterInstanceId

  MasterPrivateIp:
    Description: Private IP address of the master.
    Value: !GetAtt K8sStack.Outputs.MasterPrivateIp

  NodeGroupInstanceId:
    Description: InstanceId of the newly-created NodeGroup.
    Value: !GetAtt K8sStack.Outputs.NodeGroupInstanceId

  JoinNodes:
    Description: Command to join more nodes to this cluster.
    Value: !GetAtt K8sStack.Outputs.JoinNodes

  DatacolApiKey:
    Description: Api key for datacol CLI
    Value: !Ref ApiKey